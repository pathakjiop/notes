## ðŸ“˜ **Unit 3: Deadlocks and Memory Management**

---

## ðŸ”¹ **Part A: Deadlocks**

---

### ðŸ”¸ 1. **What is a Deadlock?**

A **deadlock** is a state where a set of processes are **blocked forever**, each waiting for a resource that is held by another process in the set.

---

### ðŸ”¸ 2. **Conditions for Deadlock**

Deadlock occurs if all **four** conditions hold **simultaneously**:

1. **Mutual Exclusion** â€“ At least one resource must be held in a non-shareable mode.
    
2. **Hold and Wait** â€“ A process is holding at least one resource and waiting for more.
    
3. **No Preemption** â€“ Resources cannot be forcibly taken.
    
4. **Circular Wait** â€“ A set of processes {P1, P2, ..., Pn} exist such that P1 is waiting for a resource held by P2, P2 for P3, ..., Pn for P1.
    

---

### ðŸ”¸ 3. **Resource Allocation Graph (RAG)**

- **Vertices**: Processes (circles), Resources (squares)
    
- **Edges**:
    
    - Assignment edge: Resource â†’ Process
        
    - Request edge: Process â†’ Resource
        

ðŸ“Œ **Cycle Detection**:

- **No cycle** â†’ No deadlock.
    
- **Cycle** â†’ Possible deadlock (definite only if each resource has one instance).
    

---

### ðŸ”¸ 4. **Deadlock Handling Strategies**

1. **Deadlock Prevention** â€“ Ensure at least one of the 4 conditions never holds.
    
2. **Deadlock Avoidance** â€“ Dynamically avoid unsafe states (e.g., Banker's Algorithm).
    
3. **Deadlock Detection and Recovery** â€“ Let deadlock occur, detect it, and recover.
    
4. **Ignore** â€“ ("Ostrich approach") â€“ Used in many OSes like UNIX.
    

---

### ðŸ”¸ 5. **Deadlock Prevention Techniques**

#### ðŸ”¹ Mutual Exclusion

- Canâ€™t prevent in all cases (some resources are non-shareable).
    

#### ðŸ”¹ Hold and Wait

- Require a process to request all resources at once (can lead to low resource utilization).
    

#### ðŸ”¹ No Preemption

- If a process requests a resource not available, release all held resources.
    

#### ðŸ”¹ Circular Wait

- Impose a linear ordering of resource types and force processes to request in that order.
    

---

### ðŸ”¸ 6. **Deadlock Avoidance: Banker's Algorithm**

A dynamic algorithm that checks for **safe state** before allocating resources.

#### **Data Structures**:

- **Available[]** â€“ Resources available
    
- **Max[][]** â€“ Maximum demand of each process
    
- **Allocation[][]** â€“ Resources currently allocated
    
- **Need[][]** = Max - Allocation
    

#### **Algorithm Steps**:

1. Check if request â‰¤ need
    
2. Check if request â‰¤ available
    
3. Pretend to allocate and check if system remains in safe state
    

If yes, allocate; otherwise, block the process.

---

### ðŸ”¸ 7. **Deadlock Detection**

For multiple instances, use a variation of Bankerâ€™s.

- Maintain:
    
    - **Available**
        
    - **Allocation**
        
    - **Request**
        

Loop through processes and mark those that can finish with current resources.

---

### ðŸ”¸ 8. **Recovery Techniques**

- **Process Termination**: Abort one or all processes in deadlock.
    
- **Resource Preemption**: Take resources from other processes (may cause starvation).
    

---

## ðŸ”¹ **Part B: Memory Management**

---

### ðŸ”¸ 1. **Introduction**

Memory management is about **efficiently allocating** main memory to processes during execution.

Goals:

- Maximize CPU and memory utilization
    
- Provide memory protection and isolation
    

---

### ðŸ”¸ 2. **Address Binding**

- **Compile-time**: Absolute addresses known at compile time
    
- **Load-time**: Final addresses are determined when program is loaded
    
- **Execution-time**: Logical â†’ Physical mapping done during execution using **MMU**
    

---

### ðŸ”¸ 3. **Logical vs Physical Address**

- **Logical Address**: Generated by CPU (also called virtual address)
    
- **Physical Address**: Actual location in memory
    

Mapping handled by **Memory Management Unit (MMU)**

---

### ðŸ”¸ 4. **Contiguous Memory Allocation**

#### ðŸ”¹ Techniques:

1. **Single Partition**: Entire memory given to one process.
    
2. **Multiple Partition**: Fixed-size or variable-size memory partitions.
    

---

### ðŸ”¸ 5. **Memory Allocation Strategies**

| Strategy      | Description                          |
| ------------- | ------------------------------------ |
| **First Fit** | Allocate first free block big enough |
| **Best Fit**  | Allocate smallest block that fits    |
| **Worst Fit** | Allocate largest available block     |

ðŸ“Œ **Problem**: Fragmentation

---

### ðŸ”¸ 6. **Fragmentation**

- **External Fragmentation**: Free memory scattered outside of allocated blocks.
    
- **Internal Fragmentation**: Unused memory inside allocated space.
    

ðŸ›  **Solution**: Compaction, Paging

---

### ðŸ”¸ 7. **Paging**

Divides memory into fixed-size **pages** and physical memory into **frames**.

- Logical address = page number + offset
    
- Page Table: Maps pages to frames
    

âœ… Eliminates external fragmentation  
ðŸ“Œ May introduce internal fragmentation

---

### ðŸ”¸ 8. **Segmentation**

Divides program into **logical segments** (code, data, stack).

- Each segment has base and limit.
    
- Logical Address = Segment Number + Offset
    
- Segment Table used for translation
    

âœ… Easy to grow independently  
ðŸ“Œ May suffer from external fragmentation
